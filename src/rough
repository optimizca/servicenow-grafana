export interface PluginQuery extends DataQuery {
  rawQuery: string;
  sysparam_query: string;
  metricAnomaly: string;
  topology_parent_depth: string;
  topology_child_depth: string;
  topology_namespaces: string;
  topology_filter: string;
  live_osquery: string;
  tableName: SelectableValue<string>;
  groupBy: SelectableValue<string>;
  aggregateColumn: string;
  rowLimit: string;
  elasticSearch: string;
  trendPeriod: string;
  showPercent: boolean;
  page: number;
  getAlertCount: SelectableValue<string>;
  compressLogs: boolean;
  grafanaTimerange: boolean;

  cacheOverride: string;

  basic_sysparam: Array<{
    1: SelectableValue<string> | null;
    2: SelectableValue<string> | null;
    3: SelectableValue<string> | null;
    4: SelectableValue<string> | null;
  }>;

  selectedQueryCategory: SelectableValue<string>;
  selectedServiceList: SelectableValue<string>;
  selectedSourceList: SelectableValue<string>;
  selectedMetricTypeList: SelectableValue<string>;
  selectedMetricNameList: SelectableValue<string>;
  selectedMetricAnomalyList: SelectableValue<string>;
  selectedAlertTypeList: SelectableValue<string>;
  selectedAlertStateList: SelectableValue<string>;
  selectedChangeTypeList: SelectableValue<string>;
  selectedTopologyDependsOnFilter: SelectableValue<string>;
  selectedAgentFilterType: SelectableValue<string>;
  selectedAgentFilter: SelectableValue<string>;
  selectedAggregateType: SelectableValue<string>;
  selectedtableColumns: SelectableValue<string>;
  sortBy: SelectableValue<string>;
  sortDirection: string;
  metricValueType: string;
  selectedTrendColumn: SelectableValue<string>;
  selectedTrendBy: SelectableValue<string>;
  grafanaTimerangeColumn: SelectableValue<string>;

  tagKeys: SelectableValue<string>;
  tagValues: SelectableValue<string>;
  relationshipTypes: Array<SelectableValue<string>>;
  excludedClasses: Array<SelectableValue<string>>;
  basicSysparm: Array<{
    column: SelectableValue<string> | null;
    operator: SelectableValue<string> | null;
    value: SelectableValue<string> | null;
    separator: SelectableValue<string> | null;
  }>;
  multiplier: number;
}


applyTemplateVariables(query: PluginQuery, scopedVars: ScopedVars): PluginQuery {
    console.log('Scoped Vars:', scopedVars); 
  
    // Interpolate the table name if it exists
    if (query.tableName && query.tableName.value) {
      const tableName = getTemplateSrv().replace(query.tableName.value, scopedVars, 'csv');
      console.log('Interpolated Table Name:', tableName); 
      query.tableName.value = tableName;
    }

    // Interpolate the column names if they exist
    if (query.selectedtableColumns && query.selectedtableColumns.length > 0) {
      const interpolatedColumns = query.selectedtableColumns.map((col) => {
        if (col.value) {
          const interpolatedValue = getTemplateSrv().replace(col.value, scopedVars, 'csv');
          console.log('Interpolated Column Value:', interpolatedValue);
          return { ...col, value: interpolatedValue }; // Return a new object with the interpolated value
        }
        return col; // Return the column as-is if no value exists
      });
      console.log('Interpolated Columns:', interpolatedColumns);
      query.selectedtableColumns = interpolatedColumns;
    }

    // Interpolate the sysparam if it exists
    if (query.sysparam_query) {
      const sysparam = getTemplateSrv().replace(query.sysparam_query, scopedVars, 'csv');
      console.log('Interpolated Sysparam:', sysparam);
      query.sysparam_query = sysparam;
    }

    // Interpolate the raw query if it exists
    if (query.rowLimit) {
      const rowLimit = getTemplateSrv().replace(query.rowLimit, scopedVars, 'csv');
      console.log('Interpolated Row Limit:', rowLimit);
      query.rowLimit = rowLimit;
    }

    // Interpolate the page no if it exists
    if (query.page) {
      const page = getTemplateSrv().replace(query.page.toString(), scopedVars, 'csv');
      console.log('Interpolated Page:', page);
      query.page = parseInt(page, 10);
    }

    // Interpolate the sort by if it exists
    if (query.sortBy && query.sortBy.value) {
      const sortBy = getTemplateSrv().replace(query.sortBy.value, scopedVars, 'csv');
      console.log('Interpolated Sort Direction:', sortBy);
      query.sortBy.value = sortBy;
    }

    // Interpolate the get alert count if it exists
    if (query.getAlertCount && query.getAlertCount.value) {
      const getAlertCount = getTemplateSrv().replace(query.getAlertCount.value, scopedVars, 'csv');
      console.log('Interpolated Get Alert Count:', getAlertCount);
      query.getAlertCount.value = getAlertCount;
    }

    // Interpolate if the grafana timerange is enabled
    if (query.grafanaTimerange) {
      const grafanaTimerange = getTemplateSrv().replace(query.grafanaTimerange.toString(), scopedVars, 'csv');
      console.log('Interpolated Grafana Timerange:', grafanaTimerange);
      query.grafanaTimerange = grafanaTimerange === 'true';
    }

    // Interpolate the group by if it exists
    if (query.groupBy && query.groupBy.value) {
      const groupBy = getTemplateSrv().replace(query.groupBy.value, scopedVars, 'csv');
      console.log('Interpolated Group By:', groupBy);
      query.groupBy.value = groupBy;
    }

    // Interpolate the service list if it exists
    if (query.selectedServiceList && query.selectedServiceList.value) {
      const serviceList = getTemplateSrv().replace(query.selectedServiceList.value, scopedVars, 'csv');
      console.log('Interpolated Service List:', serviceList);
      query.selectedServiceList.value = serviceList;
    }

    // Interpolate the show percent if it exists
    if (query.showPercent) {
      const showPercent = getTemplateSrv().replace(query.showPercent.toString(), scopedVars, 'csv');
      console.log('Interpolated Show Percent:', showPercent);
      query.showPercent = showPercent === 'true';
    }

    // Interpolate the aggregate column if it exists
    if (query.aggregateColumn) {
      const aggregateColumn = getTemplateSrv().replace(query.aggregateColumn, scopedVars, 'csv');
      console.log('Interpolated Aggregate Column:', aggregateColumn);
      query.aggregateColumn = aggregateColumn;
    }

    // Interpolate the aggregate type if it exists
    if (query.selectedAggregateType && query.selectedAggregateType.value) {
      const aggregateType = getTemplateSrv().replace(query.selectedAggregateType.value, scopedVars, 'csv');
      console.log('Interpolated Aggregate Type:', aggregateType);
      query.selectedAggregateType.value = aggregateType;
    }

    // Interpolate the parent depth if it exists
    if (query.topology_parent_depth) {
      const parentDepth = getTemplateSrv().replace(query.topology_parent_depth, scopedVars, 'csv');
      console.log('Interpolated Parent Depth:', parentDepth);
      query.topology_parent_depth = parentDepth;
    }

    // Interpolate the child depth if it exists
    if (query.topology_child_depth) {
      const childDepth = getTemplateSrv().replace(query.topology_child_depth, scopedVars, 'csv');
      console.log('Interpolated Child Depth:', childDepth);
      query.topology_child_depth = childDepth;
    }

    // Interpolate the relationship types if it exists
    if (query.relationshipTypes) {
      const relationshipTypes = query.relationshipTypes.map((relationshipType) => {
        return getTemplateSrv().replace(relationshipType.value, scopedVars, 'csv');
      });
      console.log('Interpolated Relationship Types:', relationshipTypes);
      query.relationshipTypes = relationshipTypes.map((type) => ({ value: type, label: type }));
    }
  
    // Interpolate the excluded classes if it exists
    if (query.excludedClasses) {
      const excludedClasses = query.excludedClasses.map((excludedClass) => {
        return getTemplateSrv().replace(excludedClass.value, scopedVars, 'csv');
      });
      console.log('Interpolated Excluded Classes:', excludedClasses);
      query.excludedClasses = excludedClasses.map((type) => ({ value: type, label: type }));
    }

    // Interpolate the Source List (Ci) if it exists
    if (query.selectedSourceList && query.selectedSourceList.value) {
      const sourceList = getTemplateSrv().replace(query.selectedSourceList.value, scopedVars, 'csv');
      console.log('Interpolated Source List:', sourceList);
      query.selectedSourceList.value = sourceList;
    }

    // Interpolate the Alert Type List if it exists
    if (query.selectedAlertTypeList && query.selectedAlertTypeList.value) {
      const alertTypeList = getTemplateSrv().replace(query.selectedAlertTypeList.value, scopedVars, 'csv');
      console.log('Interpolated Alert Type List:', alertTypeList);
      query.selectedAlertTypeList.value = alertTypeList;
    }

    // Interpolate the Alert State List if it exists
    if (query.selectedAlertStateList && query.selectedAlertStateList.value) {
      const alertStateList = getTemplateSrv().replace(query.selectedAlertStateList.value, scopedVars, 'csv');
      console.log('Interpolated Alert State List:', alertStateList);
      query.selectedAlertStateList.value = alertStateList;
    }

    // Interpolate the sort direction if it exists
    if (query.sortDirection) {
      const sortDirection = getTemplateSrv().replace(query.sortDirection, scopedVars, 'csv');
      console.log('Interpolated Sort Direction:', sortDirection);
      query.sortDirection = sortDirection;
    }

    // Interpolate the elastic search query if it exists
    if (query.elasticSearch) {
      const elasticSearch = getTemplateSrv().replace(query.elasticSearch, scopedVars, 'csv');
      console.log('Interpolated Elastic Search Query:', elasticSearch);
      query.elasticSearch = elasticSearch;
    }

    // Interpolate the metric type list if it exists
    if (query.selectedMetricTypeList && query.selectedMetricTypeList.value) {
      const metricTypeList = getTemplateSrv().replace(query.selectedMetricTypeList.value, scopedVars, 'csv');
      console.log('Interpolated Metric Type List:', metricTypeList);
      query.selectedMetricTypeList.value = metricTypeList;
    }

    // Interpolate the metric name list if it exists
    if (query.selectedMetricNameList && query.selectedMetricNameList.value) {
      const metricNameList = getTemplateSrv().replace(query.selectedMetricNameList.value, scopedVars, 'csv');
      console.log('Interpolated Metric Name List:', metricNameList);
      query.selectedMetricNameList.value = metricNameList;
    }

    // Interpolate the metric anomaly list if it exists
    if (query.selectedMetricAnomalyList && query.selectedMetricAnomalyList.value) {
      const metricAnomalyList = getTemplateSrv().replace(query.selectedMetricAnomalyList.value, scopedVars, 'csv');
      console.log('Interpolated Metric Anomaly List:', metricAnomalyList);
      query.selectedMetricAnomalyList.value = metricAnomalyList;
    }

    


    const interpolatedQuery: PluginQuery = {
      ...query,
      rawQuery: getTemplateSrv().replace(query.rawQuery, scopedVars, 'csv'),
    };
  
    console.log('Interpolated Query:', interpolatedQuery); // Debugging
    return interpolatedQuery;
  }

  func (sm *SNOWManager) QueryTable(
	target models.PluginQuery,
	timeFrom string,
	timeTo string,
	options map[string]string,
	cacheOverride string,
	refID string,
) ([]byte, error) {
	if utils.DebugLevel() == 1 {
		fmt.Println("queryTable target: ", target)
	}

	// Extract scopedVars
	scopedVars := options

	// Extract tableName
	tableName := ""
	if target.TableName != nil && target.TableName.Value != nil {
		if value, ok := target.TableName.Value.(string); ok {
			tableName = utils.ReplaceTargetUsingTemplVars(value, scopedVars)
		}
	}

	tableColumns := ""
	if target.SelectedTableColumns != nil {
		var columns []string
		for _, col := range target.SelectedTableColumns {
			if strVal, ok := col.Value.(string); ok {
				columns = append(columns, utils.ReplaceTargetUsingTemplVars(strVal, scopedVars))
			}
		}
		tableColumns = strings.Join(columns, ",")
	}

	// Extract sysparam
	sysparam := ""
	if target.SysparamQuery != "" {
		parsedSysparams := sm.SingleSysParamQuery(target.SysparamQuery)
		sysparam = sm.ParseBasicSysparm(parsedSysparams, options)
	}

	// Determine row limit
	limit := 9999
	if target.RowLimit != "" {
		if parsedLimit,
			err := strconv.Atoi(target.RowLimit); err == nil && parsedLimit > 0 && parsedLimit < 10000 {
			limit = parsedLimit
		}
	}
	// Determine page number
	page := 0
	if target.Page > 0 {
		page = target.Page
	}

	// Process sortBy and sortDirection
	sortBy := ""
	sortDirection := ""
	if target.SortBy != nil && target.SortBy.Value != nil {
		if sortValue, ok := target.SortBy.Value.(string); ok {
			sortBy = utils.ReplaceTargetUsingTemplVarsCSV(sortValue, scopedVars)
		}
	}

	getAlertCount := false
	if target.GetAlertCount != nil && target.GetAlertCount.Value != nil {
		if val, ok := target.GetAlertCount.Value.(string); ok {
			getAlertCount = val == "true" // Convert string to boolean
		}
	}

	// Process timerangeColumn
	timerangeColumn := "sys_updated_on"
	if target.GrafanaTimerangeColumn != nil && target.GrafanaTimerangeColumn.Value != nil {
		if value, ok := target.GrafanaTimerangeColumn.Value.(string); ok {
			timerangeColumn = utils.ReplaceTargetUsingTemplVarsCSV(value, scopedVars)
		}
	}

	// Construct bodyData
	bodyData := map[string]interface{}{
		"targets": []map[string]interface{}{
			{
				"target":        tableName,
				"columns":       tableColumns,
				"sysparm":       sysparam,
				"limit":         limit,
				"page":          page,
				"sortBy":        sortBy,
				"sortDirection": sortDirection,
				"getAlertCount": getAlertCount,
			},
		},
	}

	url := "/v1/query/table"
	if target.GrafanaTimerange {
		url += fmt.Sprintf("?startTime=%s&endTime=%s&timerangeColumn=%s", timeFrom, timeTo, timerangeColumn)
	}

	if utils.DebugLevel() == 1 {
		fmt.Println("Request URL:", url)
		fmt.Println("Request Body:", bodyData)
	}

	// Send HTTP request
	responseBytes, err := sm.APIClient.Request("POST", url, bodyData, cacheOverride)
	if err != nil {
		return nil, fmt.Errorf("table query error: %w", err)
	}

	if utils.DebugLevel() == 1 {
		fmt.Println("Response from API:", string(responseBytes))
	}

	// Parse response into result
	var response map[string]interface{}
	if err := json.Unmarshal(responseBytes, &response); err != nil {
		return nil, fmt.Errorf("failed to parse response: %w", err)
	}

	// Check if the "result" field exists and is an array
	resultInterface, ok := response["result"]
	if !ok {
		return nil, fmt.Errorf("missing 'result' field in response")
	}

	// Handle the case where the result is an empty array (if empty response is expected)
	if resultArray, ok := resultInterface.([]interface{}); ok {
		if len(resultArray) == 0 {
			return []byte("[]"), nil
		}

		// Convert []interface{} to []map[string]interface{}
		var result []map[string]interface{}
		for _, item := range resultArray {
			if itemMap, ok := item.(map[string]interface{}); ok {
				result = append(result, itemMap)
			} else {
				return nil, fmt.Errorf("unexpected item format in result array")
			}
		}

		// Map response to frames
		frame := client.MapTextResponseToFrame(result, refID)

		// Marshal frames into JSON
		frameJSON, err := json.Marshal([]*data.Frame{frame})
		if err != nil {
			return nil, fmt.Errorf("failed to marshal frame to JSON: %w", err)
		}

		return frameJSON, nil
	} else {
		return nil, fmt.Errorf("unexpected result format: expected an array")
	}
}